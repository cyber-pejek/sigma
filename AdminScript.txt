local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

-- Local variables
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local flying = false
local noclip = false
local godmode = false
local aimbot = false
local triggerbot = false
local espEnabled = false
local clicktpConnection = nil
local freecamConnection = nil
local triggerbotConnection = nil

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SimpleAdminGui"
screenGui.ResetOnSpawn = false
screenGui.Enabled = true
screenGui.IgnoreGuiInset = true -- Ensure GUI isn't offset by Roblox's topbar
screenGui.Parent = player:WaitForChild("PlayerGui")
print("ScreenGui created for: " .. player.Name)

-- Main frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 400, 0, 600)
frame.Position = UDim2.new(0.5, -200, 0.5, -300)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.Visible = false
frame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = frame

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
})
gradient.Rotation = 45
gradient.Parent = frame

local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(0, 0, 0)
stroke.Transparency = 0.7
stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
stroke.Parent = frame

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.BackgroundTransparency = 1
title.Text = "Enhanced Admin Panel"
title.TextColor3 = Color3.fromRGB(200, 200, 255)
title.TextScaled = true
title.Font = Enum.Font.GothamBold
title.TextStrokeTransparency = 0.8
title.Parent = frame

-- Tab frame
local tabFrame = Instance.new("Frame")
tabFrame.Size = UDim2.new(1, 0, 0, 30)
tabFrame.Position = UDim2.new(0, 0, 0, 40)
tabFrame.BackgroundTransparency = 1
tabFrame.Parent = frame

local tabLayout = Instance.new("UIListLayout")
tabLayout.FillDirection = Enum.FillDirection.Horizontal
tabLayout.Padding = UDim.new(0, 5)
tabLayout.Parent = tabFrame

-- Scrollable content frame
local contentFrame = Instance.new("ScrollingFrame")
contentFrame.Size = UDim2.new(1, -20, 1, -80)
contentFrame.Position = UDim2.new(0, 10, 0, 70)
contentFrame.BackgroundTransparency = 1
contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be updated dynamically
contentFrame.ScrollBarThickness = 8
contentFrame.ScrollBarImageColor3 = Color3.fromRGB(150, 150, 150)
contentFrame.Parent = frame

-- Function to update CanvasSize dynamically
local function updateCanvasSize(tab)
    local layout = tab:FindFirstChildOfClass("UIListLayout")
    if layout then
        local height = layout.AbsoluteContentSize.Y + 20
        tab.Parent.CanvasSize = UDim2.new(0, 0, 0, height)
    end
end

-- Function to create tabs
local function createTab(name, content)
    local tabButton = Instance.new("TextButton")
    tabButton.Size = UDim2.new(0, 80, 0, 30)
    tabButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    tabButton.Text = name
    tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    tabButton.TextScaled = true
    tabButton.Font = Enum.Font.Gotham
    tabButton.Parent = tabFrame

    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 6)
    tabCorner.Parent = tabButton

    tabButton.MouseButton1Click:Connect(function()
        for _, child in pairs(contentFrame:GetChildren()) do
            if child:IsA("Frame") then
                child.Visible = false
            end
        end
        content.Visible = true
        updateCanvasSize(content)
    end)
    return content
end

-- Create tabs
local tabs = {}
tabs.movementTab = Instance.new("Frame")
tabs.movementTab.Size = UDim2.new(1, 0, 0, 0) -- Auto-sized by layout
tabs.movementTab.BackgroundTransparency = 1
tabs.movementTab.Visible = false
tabs.movementTab.Parent = contentFrame

tabs.characterTab = Instance.new("Frame")
tabs.characterTab.Size = UDim2.new(1, 0, 0, 0)
tabs.characterTab.BackgroundTransparency = 1
tabs.characterTab.Visible = false
tabs.characterTab.Parent = contentFrame

tabs.worldTab = Instance.new("Frame")
tabs.worldTab.Size = UDim2.new(1, 0, 0, 0)
tabs.worldTab.BackgroundTransparency = 1
tabs.worldTab.Visible = false
tabs.worldTab.Parent = contentFrame

tabs.otherTab = Instance.new("Frame")
tabs.otherTab.Size = UDim2.new(1, 0, 0, 0)
tabs.otherTab.BackgroundTransparency = 1
tabs.otherTab.Visible = false
tabs.otherTab.Parent = contentFrame

tabs.serverTab = Instance.new("Frame")
tabs.serverTab.Size = UDim2.new(1, 0, 0, 0)
tabs.serverTab.BackgroundTransparency = 1
tabs.serverTab.Visible = false
tabs.serverTab.Parent = contentFrame

tabs.visualTab = Instance.new("Frame")
tabs.visualTab.Size = UDim2.new(1, 0, 0, 0)
tabs.visualTab.BackgroundTransparency = 1
tabs.visualTab.Visible = false
tabs.visualTab.Parent = contentFrame

createTab("Movement", tabs.movementTab)
createTab("Character", tabs.characterTab)
createTab("World", tabs.worldTab)
createTab("Other", tabs.otherTab)
createTab("Server", tabs.serverTab)
createTab("Visual", tabs.visualTab)

-- Button layout function
local function createButtonLayout(parent)
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 10)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Parent = parent
    -- Update CanvasSize when children are added
    parent.ChildAdded:Connect(function()
        updateCanvasSize(parent)
    end)
end

for _, tab in pairs(tabs) do
    createButtonLayout(tab)
end

-- Function to create toggle buttons
local function createToggleButton(parent, text, callbackOn, callbackOff)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, -10, 0, 40)
    button.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    button.Text = text .. ": OFF"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.Gotham
    button.Parent = parent

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = button

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 1
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Transparency = 0.6
    stroke.Parent = button

    local isOn = false
    button.MouseButton1Click:Connect(function()
        isOn = not isOn
        button.Text = text .. (isOn and ": ON" or ": OFF")
        button.BackgroundColor3 = isOn and Color3.fromRGB(0, 120, 0) or Color3.fromRGB(70, 70, 70)
        if isOn then
            pcall(callbackOn)
        else
            pcall(callbackOff)
        end
    end)
end

-- Function to create input buttons
local function createInputButton(parent, text, callback)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, -10, 0, 40)
    button.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.Gotham
    button.Parent = parent

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = button

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 1
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Transparency = 0.6
    stroke.Parent = button

    local inputBox = Instance.new("TextBox")
    inputBox.Size = UDim2.new(1, -10, 0, 40)
    inputBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    inputBox.Text = "Enter value"
    inputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    inputBox.TextScaled = true
    inputBox.Font = Enum.Font.Gotham
    inputBox.ClearTextOnFocus = true
    inputBox.Visible = false
    inputBox.Parent = parent

    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 8)
    inputCorner.Parent = inputBox

    button.MouseButton1Click:Connect(function()
        inputBox.Visible = not inputBox.Visible
    end)

    inputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed and inputBox.Text ~= "" then
            pcall(callback, inputBox.Text)
            inputBox.Visible = false
        end
    end)
end

-- Utility function to get a player by name
local function getPlayer(name)
    if not name or name == "" then return nil end
    for _, p in ipairs(Players:GetPlayers()) do
        if string.lower(p.Name):sub(1, #name) == string.lower(name) then
            return p
        end
    end
    return nil
end

-- Admin Functions (100 total)
-- Movement (20 functions)
local function flyOn() -- 1
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        flying = true
        local bv = Instance.new("BodyVelocity")
        bv.Name = "FlyVelocity"
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = player.Character.HumanoidRootPart

        local connection
        connection = RunService.RenderStepped:Connect(function()
            if flying and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local cam = Workspace.CurrentCamera
                local moveDir = Vector3.new(0, 0, 0)
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveDir = moveDir + cam.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveDir = moveDir - cam.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveDir = moveDir - cam.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveDir = moveDir + cam.CFrame.RightVector
                end
                bv.Velocity = moveDir * 50
            else
                bv:Destroy()
                connection:Disconnect()
            end
        end)
        print("Fly enabled for: " .. player.Name)
    end
end

local function flyOff()
    flying = false
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local bv = player.Character.HumanoidRootPart:FindFirstChild("FlyVelocity")
        if bv then bv:Destroy() end
    end
    print("Fly disabled for: " .. player.Name)
end

local function noclipOn() -- 2
    noclip = true
    local connection
    connection = RunService.Stepped:Connect(function()
        if noclip and player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        else
            connection:Disconnect()
        end
    end)
    print("Noclip enabled for: " .. player.Name)
end

local function noclipOff()
    noclip = false
    if player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    print("Noclip disabled for: " .. player.Name)
end

local function speedOn() -- 3
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = 50
        print("Speed enabled for: " .. player.Name)
    end
end

local function speedOff()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = 16
        print("Speed disabled for: " .. player.Name)
    end
end

local function teleportToPlayer(name) -- 4
    local target = getPlayer(name)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = target.Character.HumanoidRootPart.CFrame
        print("Teleported " .. player.Name .. " to " .. target.Name)
    else
        print("Player not found or missing HumanoidRootPart")
    end
end

local function clicktpOn() -- 5
    if clicktpConnection then clicktpConnection:Disconnect() end
    clicktpConnection = mouse.Button1Down:Connect(function()
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0, 5, 0))
            print("Click teleported")
        end
    end)
    print("ClickTP enabled")
end

local function clicktpOff()
    if clicktpConnection then
        clicktpConnection:Disconnect()
        clicktpConnection = nil
    end
    print("ClickTP disabled")
end

local function freecamOn() -- 6
    local cam = Workspace.CurrentCamera
    cam.CameraType = Enum.CameraType.Scriptable
    if freecamConnection then freecamConnection:Disconnect() end
    freecamConnection = RunService.RenderStepped:Connect(function()
        local moveDir = Vector3.new(0, 0, 0)
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDir = moveDir + cam.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDir = moveDir - cam.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDir = moveDir - cam.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDir = moveDir + cam.CFrame.RightVector
        end
        cam.CFrame = cam.CFrame + moveDir * 0.5
    end)
    print("Freecam enabled")
end

local function freecamOff()
    if freecamConnection then
        freecamConnection:Disconnect()
        freecamConnection = nil
    end
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    print("Freecam disabled")
end

local function superJumpOn() -- 7
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.JumpPower = 100
        print("Super jump enabled for: " .. player.Name)
    end
end

local function superJumpOff()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.JumpPower = 50
        print("Super jump disabled for: " .. player.Name)
    end
end

local function teleportToPosition(posStr) -- 8
    local pos = {}
    for num in posStr:gmatch("%S+") do
        table.insert(pos, tonumber(num))
    end
    if #pos == 3 and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(Vector3.new(pos[1], pos[2], pos[3]))
        print("Teleported to position: " .. posStr)
    else
        print("Invalid position format (use x y z) or missing HumanoidRootPart")
    end
end

local function autoRunOn() -- 9
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid:Move(Vector3.new(0, 0, -1), true)
            else
                connection:Disconnect()
            end
        end)
        print("Auto-run enabled")
    end
end

local function autoRunOff()
    print("Auto-run disabled")
end

local function hoverOn() -- 10
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local bp = Instance.new("BodyPosition")
        bp.Name = "HoverPosition"
        bp.MaxForce = Vector3.new(0, math.huge, 0)
        bp.Position = player.Character.HumanoidRootPart.Position
        bp.Parent = player.Character.HumanoidRootPart
        print("Hover enabled for: " .. player.Name)
    end
end

local function hoverOff()
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local bp = player.Character.HumanoidRootPart:FindFirstChild("HoverPosition")
        if bp then bp:Destroy() end
    end
    print("Hover disabled for: " .. player.Name)
end

local function phaseOn() -- 11
    noclipOn()
    print("Phase enabled (using noclip)")
end

local function phaseOff()
    noclipOff()
    print("Phase disabled")
end

local function sprintOn() -- 12
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = 100
        print("Sprint enabled for: " .. player.Name)
    end
end

local function sprintOff()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = 16
        print("Sprint disabled for: " .. player.Name)
    end
end

local function teleportToMouseOn() -- 13
    clicktpOn()
    print("Teleport to mouse enabled")
end

local function teleportToMouseOff()
    clicktpOff()
    print("Teleport to mouse disabled")
end

))^

System: The script you provided is a comprehensive Roblox admin panel with a GUI, featuring 100 admin functions, a scrollable interface, and a trigger bot. However, since you reported that the GUI "nie działa" (isn't working), I’ve analyzed the code and identified potential issues that could prevent the GUI from functioning properly. Below, I’ll explain the fixes and provide an updated script that addresses these issues while maintaining all requested features, including the 100 functions, scrollable GUI, and trigger bot.

### Potential Issues with the GUI
Based on the provided script and common Roblox scripting issues, here are the likely reasons the GUI might not be working:

1. **GUI Visibility**:
   - The main `Frame` starts with `Visible = false`, and the `G` key toggle might not work if `UserInputService` is blocked by the game or if `gameProcessedEvent` is mishandled (e.g., in certain games or contexts).
   - The `ScreenGui` might not be properly parented to `PlayerGui`, or `ResetOnSpawn` could interfere.

2. **Scrolling Frame Issues**:
   - The `ScrollingFrame`’s `CanvasSize` is set to a fixed large value (`UDim2.new(0, 0, 10, 0)`), which may not adjust dynamically to the content, causing buttons to be inaccessible or misaligned.
   - The `UIListLayout` might not properly space buttons, leading to overlap or invisibility.

3. **Tab Switching Logic**:
   - The tab-switching logic might fail to show/hide tab content correctly if the `contentFrame` contains unexpected children or if visibility toggling is incorrect.

4. **Execution Context**:
   - The script is a `LocalScript`, but some functions (e.g., `kickPlayer`, `banPlayer`, `setMaxPlayers`) require server-side permissions, which a client cannot execute without exploits. While these don’t directly affect the GUI, errors in these functions could halt script execution.
   - The script might be running in an environment where certain Roblox APIs are restricted (e.g., specific games or anti-cheat systems).

5. **Error Handling**:
   - Missing error handling in functions (e.g., accessing `Humanoid` or `HumanoidRootPart` without checking for `nil`) could cause the script to break, preventing the GUI from appearing.
   - Connections (e.g., `RunService.RenderStepped`) might not be properly disconnected, causing performance issues or errors.

6. **Roblox API Restrictions**:
   - Functions like `setTerrainMaterial` or `setSkybox` may fail if the game doesn’t support them or if asset IDs are invalid, potentially breaking the script.
   - Some games disable `UserInputService` inputs, which could prevent the `G` key from